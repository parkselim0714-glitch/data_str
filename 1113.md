# 202530212 박 세림

# 11월 06일 대림테크페어
![대림테크](./daelim1.jpg)
![대림테크](daelim2.jpg)

# 11월 13일 강의

## 리스트
**리스트**
* 데이터를 순서대로 나열해 놓은 자료구조
* 가장 단순한 구조를 가진 리스트를 선형 리스트 또는 연결 리스트라고 함
* 그림 8-2를 보면 A부터 F까지 6개의 데이터가 순서대로 나열되어 있고 각각의 데이터가 화살표로 연결되어 있음
* 각 데이터의 연결 관계를 '이야기 전달하기 게임'에 비유할 수 있음
* 즉, 한 사람을 건너뛰어 이야기를 전달할 수 없음

## 노드
**노드**
* 리스트의 각 요소
* 각각의 노드는 데이터와 다음 노드를 가리키는 포인터를 가지고 잇음
* 처음과 끝에 있는 노드는 특별히 각각 머리 노드, 꼬리 노드라고 함
* 하나의 노드에 대해 바로 앞에 있는 노드를 앞쪽 노드, 바로 뒤에 있는 노드를 다음 노드라고 함

## 선형 리스트
**다음 노드 꺼내기**
* 배열의 각 요소에는 연락할 순서대로 데이터가 저장
* 전화를 걸기 위해 필요한 '다음 노드 꺼내기'는 1만큼 큰 인덱스를 갖는 요소에 접근하면 됨

**노드의 삽입과 삭제**
* 회원번호가 55인 회원이 새로 가입했고 이 회원의 정보를 회원번호 12, 33 사이에 삽입하려면 [b]와 같이 삽입 요소 다음의 모든 요소를 하나씩 뒤로 밀어야 함
* 삭제하는 경우도 모든 요소를 뒤로 밀거나 앞으로 당겨야 함
* 이런 작업이 필요하기 때문에 배열로 구현한 선형 리스트는 쌓이는 데이터의 크기를 미리 알아야 함
* 데이터의 삽입, 삭제에 따라 데이터를 모두 옮겨야 하기 때문에 효율이 좋지 않음

## 포인터를 이용한 연결 리스트
**노드용 구조체**
* 노드용 객체를, 연결 리스트에 데이터를 삽입할 때 만들고 삭제할 때 없애면, 앞에서 제시한 데이터를 밀고 당기는 문제를 해결할 수 있음
* 노드용 구조체 Node는 다음의 두 멤버, data와 next로 구성
    * data... 데이터(Member형)
    * next... 다음 노드에 대한 포인터(자기 자신과 같은 구조체형을 가리키는 포인터형)
* 이와 같이 자기 자신과 같은 자료형의 개게를 가리키는 데이터가 내부에 포함
* 이러한 자료구조를 자기 참조형이라고 함

**연결 리스트를 고나리하는 구조체 list**
* 노드용 구조체 Node를 사용한 연결 리스트를 나타낸 것
* List는 두 멤버로 구성되어 있고 모두 Node에 대한 포인터 자료형을 가지고 있음
* head는 연결 리스트의 머리 노드를 가리키는 머리 포인터이고, crnt는 현재 선택한 노드를 가리키는 선택 포인터
* '검색'한 노드를 선택하고 '삭제'하는 용도로 사용
* 연결 리스트를 관리하는 구조체 list는 2개의 포인터만 가짐
* 그림 8-5에 나타낸 A~D의 각 노드는 Node형 객체이지 List의 일부는 아님
* **crnt: 현재 선택한 노드를 가리키는 포인터(커서)**

**노드를 만드는 AllocNode 함수**
* Node형 객체를 만들고 만든 객체의 포인터를 반환

**노드의 멤버값을 성정하는 SetNode 함수**
* Node형 객체의 두 멤버(data, next)의 값을 설정하는 함수
* 첫 번째 매개변수 n으로 전달받은 포인터가 가리키는 Node형 객체에 x가 가리키는 값을 대입하고 n의 next에 세 번째 매개변수로 전달받은 next를 대입

**연결 리스트를 초기화하는 Initialize 함수**
* 머리 노드를 가리키는 list -> head에 NULL 값을 대입하여 노드가 하나도 없는 텅 빈 연결 리스트를 만듦

**a. 연결 리스트가 비어 있는 지 판단하는 방법**
* 빈 연결 리스트는 노드가 하나도 없는 상태이기 때문에 head가 가리키는 노드도 없음

**b. 노드가 1개인 연결 리스트를 판단하는 방법**
* 머리 포인터 list -> head가 가리키는 노드는 머리 노드 A
* 머리 노드 A는 리스트의 꼬리 노드이기도 하므로 next값은 널

**c. 노드가 2개인 연결 리스트를 판단하는 방법**
* 머리 노드는 A, 두 번째 노드이자 꼬리 노드는 B
* 머리 포인터 list -> head가 가리키는 노드 A의 뒤쪽 포인터 next는 노드 B를 가리킴
* 꼬리 노드 B의 뒤쪽 포인터 next는 NULL값을 가짐

**포인터가 머리 노드를 가리키는 지 판단하는 방법**
* 자료형이 Node *형인 변수 p는 리스트의 노드 중 하나를 가리킴
* 변수 p가 가리키는 노드가 연결 리스트의 머리 노드인지 판단하는 방법은 밑과 같음

**포인터가 꼬리 노드를 가리키는 지 판단하는 방법**
* 변수 p가 가리키는 노드가 연결 리스트의 꼬리 노드인지 판단하는 방법은 밑과 같음

**검색을 수행하는 Search 함수(1)**
* 어떤 조건을 만족하는 노드를 검색
* 전달받는 매개변수
    * list... 검색 대상인 연결 리스트를 가리키는 포인터
    * x... 검색하는 키값을 저장한 회원 데이터를 가리키는 포인터
    * compare... 두 번째 매개변수 x가 가리키는 객체와, 연결 리스트의 노드 안의 데이터를 비교하는 함수를 가리키는 포인터로 이 비교 함수는 검새겡 성공하면 0을 반환
* 이 함수가 반환하는 값은 찾은 노드에 대한 포인터이고 만약 검색에 실패하면 널을 반환

**검색을 수행하는 Search 함수(2)**
* 검색에 사용하는 알고리즘은 선형 검색이고, 그림 8-7처럼 검색할 노드를 만날 때까지 머리 노드부터 스캔
* 노드 스캔은 아래의 조건 중 하나만 성립하면 종료
    * 검색 조건을 만족하는 노드를 찾지 못하고 꼬리 노드를 지나가기 직전인 경우
    * 검색 조건을 만족하는 노드를 찾은 경우

**검색 과정(1)**
* 1. 스캔하고 있는 노드를 가리키는 포인터 ptr을 list -> head로 초기화
    * 그림 a와 같이 ptr이 가리키는 노드는 list -> head가 가리키고 있는 머리 노드인 A
* 2. 종료 조건 1을 먼저 판단
    * ptr 값이 널이 아니면 루프 본문의 3, 4를 실행
    * ptr 값이 널이면 스캔할 노드가 없음을 의미하기 때문에 while 문을 빠져나와 5로 진행

**검색 과정(2)**
* 3. 종료 조건 2를 판단하기 위해 스캔하고 있는 노드의 데이터(ptr -> data)와 x가 가리키는 데이터를 compare 함수로 비교
    * compare 함수는 검색에 성공하면 0을 반환
    * 즉, 종료 조건 2가 성립
    * 곧바로 포인터 list -> crnt에 ptr을 대입하고 찾은 노드에 대한 포인터인 ptr을 반환
* 4. ptr에 ptr -> next를 대입
    * 이렇게 하면 ptr이 다음 노드를 가리키기 때문에 게속해서 스캔할 수 있음
* 5. 검색에 실패하면 널을 반환

**머리에 노드를 삽입하는 InsertFront 함수(1)**
* 1. 삽입 전의 머리 노드 A에 대한 머리 포인터를 ptr에 대입
* 2. 삽입할 노드 G를 AllocNode 함수로 만들고 만든 노드 G를 가리키도록 머리 포인터 list -> head를 업데이트
* 3. SetNode 함수를 호출하여 값을 설정
    * 이때 삽입한 다음 머리 노드의 다음을 가리키는 포인터의 값을 ptr(삽입하기 전의 머리 노드 A)로 업데이트

**꼬리에 노드를 삽입하는 InsertRear 함수(2)**
* 4. 꼬리 노드를 찾음
    * 머리 노드를 가리키도록 초기화한 ptr이 가리키는 노드를, 계속해서 다음 노드를 가리키도록 업데이트하는 과정을 반복
    * 이렇게 반복하면 노드를 처음부터 차례로 스캔할 수 있음
    * ptr -> next가 가리키는 노드가 널이 되면 while 문을 종료
    * 이때 ptr이 가리키는 노드는 꼬리 노드 F

* 5. 삽입할 노드 G를 AllocNode 함수로 만듦
    * 그리고 삽입하기 전의 꼬리 노드 F의 다음 포인터 ptr -> next가 가리키는 노드에, 삽입한 다음의 꼬리 노드 G를 대입
    * 그런 다음 SetNode 함수를 호출해 앞에서 만든 노드 G의 값을 설정
    * 이때 노드 G의 다음 노드에 널을 대입

**머리 노드를 삭제하는 RemoveFront 함수**
* 리스트가 비어 있지 않은 경우(list -> head != NULL)에만 삭제를 실행
* 삭제하기 전의 머리 노드 Aㅡ이 메모리 영역을 해제
* 머리 노드에 대한 포인터 list -> head -> next를 대입하여 머리 노드에 대한 포인터가 노드 B를 가리키도록 업데이트
* 만약 리스트에 노드가 1개만 있어도 오류 없이 삭제할 수 있고 리스트는 빈 상태가 됨
* 삭제하기 전의 머리 노드는 꼬리 노드이기 때문에 다음 노드를 가리키는 list -> head -> next의 값은 널
* 널을 list -> head에 대입하면 리스트는 빈 상태가 됨

**꼬리 노드를 삭제하는 RemoveFront 함수**
* 리스트에 노드가 1개뿐인지(list -> next == NULL) 아니면 2개 이상인지에 따라 서로 다른 작업을 수행
    * 1. 리스트에 노드가 1개만 있는 경우: 머리 노드를 삭제하는 것과 같아 RemoveFront 함수로 처리
    * 2. 리스트에 노드가 2개 이상 있는 경우: 그림 8-12의 과정
* 1. '꼬리 노드'와 '꼬리 노드로 부터 두 번째 노드'를 찾음
    * 스캔하는 방법은 InsertRear 함수와 비슷하지만 현재 스캔하고 있는 노드의 '앞에 있는 노드'를 가리키는 변수 pre를 추가한 점이 다름
    * while문이 종료되면 pre는 노드 E를 , ptr은 노드 F를 가리킴
* 2. 꼬리 노드부터 두 번째 노드 E의 다음을 가리키는 포인터에 널을 대입하고 꼬리 노드 F의 메모리 영역을 해제

**선택한 노드를 삭제하는 RemoveCurrent 함수(1)**
* 현재 선택한 포인터(list -> crnt)가 가리키는 노드를 삭제하는 함수
* 삭제할 노드가 머리 노드인지 아닌지에 따라 다음의 작업을 수행
    * 1. crnt가 머리 노드인 경우: 머리 노드를 삭제하면 되므로 RemoveFront 함수로 처리
    * 2. crnt가 머리 노드가 아닌 경우: 그림 8-13의 과정

**리스트의 모드 노드를 출력하는 print 함수**
* 머리 노드부터 꼬리 노드까지 포인터 ptr이 가리키는 데이터를 출력

**연결 리스트를 종료하는 Terminate 함수**
* 모든 노드를 삭제하는 Clear 함수를 호출

**각 함수를 실행한 후의 crnt 값**

![이미지](./list.jpg)

## 커서로 연결 리스트 만들기
**커서를 사용한 연결 리스트(1)**
* 프로그램 실행 중에 데이터의 개수가 크게 바뀌지 않고 데이터 개수의 최댓값을 미리 알 수 있다고 가정하면 그림 8-14처럼 배열을 사용해 효율적으로 연결 리스트를 운용할 수 있음
* 배열의 커서에 해당하는 값은 다음 노드에 대한 포인터가 아니라 다음 노드가 들어 있는 요소의 인덱스에 대한 값
    * 여기서 포인터 역할을 하는 인덱스를 커서라고 함

**커서를 사용한 연결 리스트(2)**
* 꼬리 노드의 커서는 배열의 인덱스로는 있을 수 없는 값인 - 1
* 머리 노드를 나타내는 head도 커서이기 때문에 머리 노드 A가 드렁 있는 곳인 인덱스 1이 head의 값이 됨
* 이와 같은 방법을 사용하면 노드의 삽입, 삭제 시 요소를 옮길 필요가 없음
* 예를 들어, 그림 8-14의 연결 리스트의 머리에 노드 G를 삽입하면 그림 8-15와 같은 상태가 됨
* head를 1에서 6으로 업데이트하고 노드 G의 커서에 1을 대입하면 됨
* 이러한 점이 앞서 08-1절에서 살펴본 '배열로 선형 리스트 만들기'와의 큰 차이점

**커서를 사용한 연결 리스트**
* 프로그램 실행 중에 데이터의 개수가 크게 바뀌지 않고 데이터 개수의 최댓값을 미리 알 수 있다고 가정하면 그림 8-14처럼 배열을 사용해 효율적으로 연결 리스트를 운용할 수 있음
* 배열의 커서에 해당하는 값은 다음 노드에 대한 포인터가 아니라 다음 노드가 들어 있는 요소의 인덱스에 대한 값
    * 여기서 포인터 역할을 하는 인덱스를 커서라고 함

**노드의 삽입과 삭제**
* a. 연결 리스트에 4개의 노드가 A -> B -> C -> D 순서대로 나열 되어 있는 상태
    * 이때 배열에 데이터가 들어 있는 순서는 A -> B -> C -> D가 아니라 머리부터 차례대로 C -> A -> D -. B
* b. 연결 리스트의 머리에 노드 E를 삽입한 다음의 상태
    * 이렇게 삽입한 노드는 물리적으로는 '배열의 꼬리 인덱스 위치'에 들어 있는 것 같지만 '연결 리스트의 꼬리'에 추가한 것이 아니라 머리에 삽입한 것
    * 다시 말해 배열에 저장한 데이터의 물리적인 위치(1, 2, 3번째)는 연결 리스트에 저장된 데이터의 논리적인 순서와 다름
* c. 3번째 노드 B를 삭제한 다음의 상태
* 이렇게 삭제를 여러 번하면 배열은 빈 레코드가 너무 많아져 효율이 떨어지므로 비어 있는 레코드를 효율적으로 활용해야 함

## 프리 리스트 구현하기
**프리 리스트**
* 삭제한 레코드를 관리하기 위해 사용하는 자료구조
* 삭제한 여러 레코드를 관리하면 앞에서 발생한 '사용하지 않은 빈 배열'의 문제를 해결할 수 있음
* 프리 리스트는 앞에서 다룬 '커서로 연결 리스트 만들기'와 삭제한 레코드를 관리하기 위한 프리 리스트를 결합해 구현
* 노드 구조체 Node에 추가한 멤버
    * Dnext... 프리 리스트의 다음 포인터(프리 리스트의 다음 노드를 가리키는 다음 커서)
* 연결 리스트를 관리하는 구조체 list에 추가한 멤버
    * deleted... 프리 리스트의 머리 커서(프리 리스트의 머리 노드를 가리키는 커서)

**노드의 삽입에 따라 프리 리스트가 변화하는 모습(1)**

**노드의 삽입에 따라 프리 리스트가 변화하는 모습(2)**


## 이중 원형 리스트
**원형 리스트**
* 선형 리스트의 꼬리 노드가 머리 노드를 가리킴
* 고리 모양으로 나열된 데이터를 저장할 때 알맞은 자료구조
* 원형 리스트와 선형 리스트의 차이점은 꼬리 노드의 다음 노드를 가리키는 포인터가 NULL이 아니라 머리 노드의 포인터값이라는 점
* 원형 리스트는 선형 리스트에서 사용했던 것과 같은 자료형을 사용할 수 있음

**빈 원형 리스트를 판단하는 방법**
* 노드가 없는(비어있는) 원형 리스트인지 판단하려면 오른쪽 식을 사용

**노드가 1개인 원형 리스트를 판단하는 방법**
* 노드가 1개라면 머리 노드의 다음 포인터는 자기 자신인 머리 노드를 가리킴

**포인터가 머리 노드를 가리키는지 판단하는 방법**
* Node *형 변수 p가 리스트에 있는 어떤 노드를 가리키는 경우 p가 가리키고 있는 노드가 원형 리스트의 머리 노드인지 판단하려면 오른쪽 식을 사용

**포인터가 꼬리 노드를 가리키는 지 판단하는 방법**
* Node *형 변수 p가 리스트에 있는 어떤 노드를 가리키는 경우 p가 가리키고 있는 노드가 원형 리스트의 꼬리 노드인지 판단하려면 오른쪽 식을 사용

**이중 연결 리스트**

**포인터가 머리 노드를 가리키는 지 판단하는 방법**

**포인터가 꼬리 노드를 가리키는 지 판단하는 방법**

**원형 이중 연결 리스트**
* 앞에서 공부한 두 가지의 개념을 합함

**노드를 나타내는 구조체Dnode**

**원형 이중 연결 리스트를 관리하는 구조체 Dlist**

**노드를 생성하는 AllocDnode 함수**

**노드의 멤버값을 설정하는 SetDnode 함수**

**원형 이중 연결 리스트를 초기화하는 Initialize 함수**

**리스트가 비어 있는지 검사하는 IsEmpty 함수**

**선택한 노드의 데이터를 출력하는 PrintCurrent/PrintLnCurrent 함수**

**노드를 검색하는 Search 함수(1)**

**노드를 검색하는 Search 함수(2)**

**노드를 검색하는 Search 함수(3)**

**모든 노드를 거꾸로 출력하는 PrintReverse 함수**

**선택한 노드의 다음으로 진행시키는 Next 함수**

**선택한 노드의 앞쪽으로 진행시키는 Prev 함수**

**바로 다음에 노드를 삽입하는 InsertAfter 함수(1)**

**바로 다음에 노드를 삽입하는 InsertAfter 함수(2)**

**머리에 노드를 삽입하는 InsertFront 함수**
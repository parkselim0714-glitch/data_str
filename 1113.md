# 202530212 박 세림

# 11월 06일 대림테크페어
![대림테크](image/daelim1.jpg)
![대림테크](image/daelim2.jpg)

# 11월 13일 강의

## 리스트
**리스트**

![list](image/list3.png)
* 데이터를 순서대로 나열해 놓은 자료구조
* 가장 단순한 구조를 가진 리스트를 선형 리스트 또는 연결 리스트라고 함
* 그림 8-2를 보면 A부터 F까지 6개의 데이터가 순서대로 나열되어 있고 각각의 데이터가 화살표로 연결되어 있음
* 각 데이터의 연결 관계를 '이야기 전달하기 게임'에 비유할 수 있음
* 즉, 한 사람을 건너뛰어 이야기를 전달할 수 없음

## 노드
**노드**
* 리스트의 각 요소
* 각각의 노드는 데이터와 다음 노드를 가리키는 포인터를 가지고 잇음
* 처음과 끝에 있는 노드는 특별히 각각 머리 노드, 꼬리 노드라고 함
* 하나의 노드에 대해 바로 앞에 있는 노드를 앞쪽 노드, 바로 뒤에 있는 노드를 다음 노드라고 함

## 선형 리스트

![list](image/list2.png)
**다음 노드 꺼내기**
* 배열의 각 요소에는 연락할 순서대로 데이터가 저장
* 전화를 걸기 위해 필요한 '다음 노드 꺼내기'는 1만큼 큰 인덱스를 갖는 요소에 접근하면 됨

**노드의 삽입과 삭제**
* 회원번호가 55인 회원이 새로 가입했고 이 회원의 정보를 회원번호 12, 33 사이에 삽입하려면 [b]와 같이 삽입 요소 다음의 모든 요소를 하나씩 뒤로 밀어야 함
* 삭제하는 경우도 모든 요소를 뒤로 밀거나 앞으로 당겨야 함
* 이런 작업이 필요하기 때문에 배열로 구현한 선형 리스트는 쌓이는 데이터의 크기를 미리 알아야 함
* 데이터의 삽입, 삭제에 따라 데이터를 모두 옮겨야 하기 때문에 효율이 좋지 않음

## 포인터를 이용한 연결 리스트
**노드용 구조체**
* 노드용 객체를, 연결 리스트에 데이터를 삽입할 때 만들고 삭제할 때 없애면, 앞에서 제시한 데이터를 밀고 당기는 문제를 해결할 수 있음
* 노드용 구조체 Node는 다음의 두 멤버, data와 next로 구성
    * data... 데이터(Member형)
    * next... 다음 노드에 대한 포인터(자기 자신과 같은 구조체형을 가리키는 포인터형)
* 이와 같이 자기 자신과 같은 자료형의 개게를 가리키는 데이터가 내부에 포함
* 이러한 자료구조를 자기 참조형이라고 함

**연결 리스트를 고나리하는 구조체 list**

![list](image/list.png)
* 노드용 구조체 Node를 사용한 연결 리스트를 나타낸 것
* List는 두 멤버로 구성되어 있고 모두 Node에 대한 포인터 자료형을 가지고 있음
* head는 연결 리스트의 머리 노드를 가리키는 머리 포인터이고, crnt는 현재 선택한 노드를 가리키는 선택 포인터
* '검색'한 노드를 선택하고 '삭제'하는 용도로 사용
* 연결 리스트를 관리하는 구조체 list는 2개의 포인터만 가짐
* 그림 8-5에 나타낸 A~D의 각 노드는 Node형 객체이지 List의 일부는 아님
* **crnt: 현재 선택한 노드를 가리키는 포인터(커서)**

**노드를 만드는 AllocNode 함수**
* Node형 객체를 만들고 만든 객체의 포인터를 반환

**노드의 멤버값을 성정하는 SetNode 함수**
* Node형 객체의 두 멤버(data, next)의 값을 설정하는 함수
* 첫 번째 매개변수 n으로 전달받은 포인터가 가리키는 Node형 객체에 x가 가리키는 값을 대입하고 n의 next에 세 번째 매개변수로 전달받은 next를 대입

**연결 리스트를 초기화하는 Initialize 함수**
* 머리 노드를 가리키는 list -> head에 NULL 값을 대입하여 노드가 하나도 없는 텅 빈 연결 리스트를 만듦

**a. 연결 리스트가 비어 있는 지 판단하는 방법**
* 빈 연결 리스트는 노드가 하나도 없는 상태이기 때문에 head가 가리키는 노드도 없음

**b. 노드가 1개인 연결 리스트를 판단하는 방법**
* 머리 포인터 list -> head가 가리키는 노드는 머리 노드 A
* 머리 노드 A는 리스트의 꼬리 노드이기도 하므로 next값은 널

**c. 노드가 2개인 연결 리스트를 판단하는 방법**
* 머리 노드는 A, 두 번째 노드이자 꼬리 노드는 B
* 머리 포인터 list -> head가 가리키는 노드 A의 뒤쪽 포인터 next는 노드 B를 가리킴
* 꼬리 노드 B의 뒤쪽 포인터 next는 NULL값을 가짐

![point](image/point3.png)

**포인터가 머리 노드를 가리키는 지 판단하는 방법**

![point](image/point1.png)
* 자료형이 Node *형인 변수 p는 리스트의 노드 중 하나를 가리킴
* 변수 p가 가리키는 노드가 연결 리스트의 머리 노드인지 판단하는 방법은 밑과 같음

**포인터가 꼬리 노드를 가리키는 지 판단하는 방법**

![point](image/point2.png)
* 변수 p가 가리키는 노드가 연결 리스트의 꼬리 노드인지 판단하는 방법은 밑과 같음

**검색을 수행하는 Search 함수(1)**
* 어떤 조건을 만족하는 노드를 검색
* 전달받는 매개변수
    * list... 검색 대상인 연결 리스트를 가리키는 포인터
    * x... 검색하는 키값을 저장한 회원 데이터를 가리키는 포인터
    * compare... 두 번째 매개변수 x가 가리키는 객체와, 연결 리스트의 노드 안의 데이터를 비교하는 함수를 가리키는 포인터로 이 비교 함수는 검새겡 성공하면 0을 반환
* 이 함수가 반환하는 값은 찾은 노드에 대한 포인터이고 만약 검색에 실패하면 널을 반환

**검색을 수행하는 Search 함수(2)**

![Search](image/Search6.png)
* 검색에 사용하는 알고리즘은 선형 검색이고, 그림 8-7처럼 검색할 노드를 만날 때까지 머리 노드부터 스캔
* 노드 스캔은 아래의 조건 중 하나만 성립하면 종료
    * 검색 조건을 만족하는 노드를 찾지 못하고 꼬리 노드를 지나가기 직전인 경우
    * 검색 조건을 만족하는 노드를 찾은 경우

**검색 과정(1)**

![Search](image/Search5.png)
* 1. 스캔하고 있는 노드를 가리키는 포인터 ptr을 list -> head로 초기화
    * 그림 a와 같이 ptr이 가리키는 노드는 list -> head가 가리키고 있는 머리 노드인 A
* 2. 종료 조건 1을 먼저 판단
    * ptr 값이 널이 아니면 루프 본문의 3, 4를 실행
    * ptr 값이 널이면 스캔할 노드가 없음을 의미하기 때문에 while 문을 빠져나와 5로 진행

**검색 과정(2)**

![Search](image/Search4.png)
* 3. 종료 조건 2를 판단하기 위해 스캔하고 있는 노드의 데이터(ptr -> data)와 x가 가리키는 데이터를 compare 함수로 비교
    * compare 함수는 검색에 성공하면 0을 반환
    * 즉, 종료 조건 2가 성립
    * 곧바로 포인터 list -> crnt에 ptr을 대입하고 찾은 노드에 대한 포인터인 ptr을 반환
* 4. ptr에 ptr -> next를 대입
    * 이렇게 하면 ptr이 다음 노드를 가리키기 때문에 게속해서 스캔할 수 있음
* 5. 검색에 실패하면 널을 반환

**머리에 노드를 삽입하는 InsertFront 함수(1)**

![InserFront](image/InsertFront2.png)
* 1. 삽입 전의 머리 노드 A에 대한 머리 포인터를 ptr에 대입
* 2. 삽입할 노드 G를 AllocNode 함수로 만들고 만든 노드 G를 가리키도록 머리 포인터 list -> head를 업데이트
* 3. SetNode 함수를 호출하여 값을 설정
    * 이때 삽입한 다음 머리 노드의 다음을 가리키는 포인터의 값을 ptr(삽입하기 전의 머리 노드 A)로 업데이트

**꼬리에 노드를 삽입하는 InsertRear 함수(2)**

![head](image/InsertRear.png)
* 4. 꼬리 노드를 찾음
    * 머리 노드를 가리키도록 초기화한 ptr이 가리키는 노드를, 계속해서 다음 노드를 가리키도록 업데이트하는 과정을 반복
    * 이렇게 반복하면 노드를 처음부터 차례로 스캔할 수 있음
    * ptr -> next가 가리키는 노드가 널이 되면 while 문을 종료
    * 이때 ptr이 가리키는 노드는 꼬리 노드 F

* 5. 삽입할 노드 G를 AllocNode 함수로 만듦
    * 그리고 삽입하기 전의 꼬리 노드 F의 다음 포인터 ptr -> next가 가리키는 노드에, 삽입한 다음의 꼬리 노드 G를 대입
    * 그런 다음 SetNode 함수를 호출해 앞에서 만든 노드 G의 값을 설정
    * 이때 노드 G의 다음 노드에 널을 대입

**머리 노드를 삭제하는 RemoveFront 함수**

![RemoveFront](image/RemoveFront.png)
* 리스트가 비어 있지 않은 경우(list -> head != NULL)에만 삭제를 실행
* 삭제하기 전의 머리 노드 Aㅡ이 메모리 영역을 해제
* 머리 노드에 대한 포인터 list -> head -> next를 대입하여 머리 노드에 대한 포인터가 노드 B를 가리키도록 업데이트
* 만약 리스트에 노드가 1개만 있어도 오류 없이 삭제할 수 있고 리스트는 빈 상태가 됨
* 삭제하기 전의 머리 노드는 꼬리 노드이기 때문에 다음 노드를 가리키는 list -> head -> next의 값은 널
* 널을 list -> head에 대입하면 리스트는 빈 상태가 됨

**꼬리 노드를 삭제하는 RemoveFront 함수**

![RemoveCurrent](image/RemoveCurrent1.png)
* 리스트에 노드가 1개뿐인지(list -> next == NULL) 아니면 2개 이상인지에 따라 서로 다른 작업을 수행
    * 1. 리스트에 노드가 1개만 있는 경우: 머리 노드를 삭제하는 것과 같아 RemoveFront 함수로 처리
    * 2. 리스트에 노드가 2개 이상 있는 경우: 그림 8-12의 과정
* 1. '꼬리 노드'와 '꼬리 노드로 부터 두 번째 노드'를 찾음
    * 스캔하는 방법은 InsertRear 함수와 비슷하지만 현재 스캔하고 있는 노드의 '앞에 있는 노드'를 가리키는 변수 pre를 추가한 점이 다름
    * while문이 종료되면 pre는 노드 E를 , ptr은 노드 F를 가리킴
* 2. 꼬리 노드부터 두 번째 노드 E의 다음을 가리키는 포인터에 널을 대입하고 꼬리 노드 F의 메모리 영역을 해제

**선택한 노드를 삭제하는 RemoveCurrent 함수(1)**

![RemoveCurrent](image/RemoveCurrent2.png)
* 현재 선택한 포인터(list -> crnt)가 가리키는 노드를 삭제하는 함수
* 삭제할 노드가 머리 노드인지 아닌지에 따라 다음의 작업을 수행
    * 1. crnt가 머리 노드인 경우: 머리 노드를 삭제하면 되므로 RemoveFront 함수로 처리
    * 2. crnt가 머리 노드가 아닌 경우: 그림 8-13의 과정

**리스트의 모드 노드를 출력하는 print 함수**
* 머리 노드부터 꼬리 노드까지 포인터 ptr이 가리키는 데이터를 출력

**연결 리스트를 종료하는 Terminate 함수**
* 모든 노드를 삭제하는 Clear 함수를 호출

**각 함수를 실행한 후의 crnt 값**

![이미지](image/list.jpg)

## 커서로 연결 리스트 만들기
**커서를 사용한 연결 리스트(1)**

![cursor](image/cursor1.png)
* 프로그램 실행 중에 데이터의 개수가 크게 바뀌지 않고 데이터 개수의 최댓값을 미리 알 수 있다고 가정하면 그림 8-14처럼 배열을 사용해 효율적으로 연결 리스트를 운용할 수 있음
* 배열의 커서에 해당하는 값은 다음 노드에 대한 포인터가 아니라 다음 노드가 들어 있는 요소의 인덱스에 대한 값
    * 여기서 포인터 역할을 하는 인덱스를 커서라고 함

**커서를 사용한 연결 리스트(2)**

![cursor](image/cursor2.png)
* 꼬리 노드의 커서는 배열의 인덱스로는 있을 수 없는 값인 - 1
* 머리 노드를 나타내는 head도 커서이기 때문에 머리 노드 A가 드렁 있는 곳인 인덱스 1이 head의 값이 됨
* 이와 같은 방법을 사용하면 노드의 삽입, 삭제 시 요소를 옮길 필요가 없음
* 예를 들어, 그림 8-14의 연결 리스트의 머리에 노드 G를 삽입하면 그림 8-15와 같은 상태가 됨
* head를 1에서 6으로 업데이트하고 노드 G의 커서에 1을 대입하면 됨
* 이러한 점이 앞서 08-1절에서 살펴본 '배열로 선형 리스트 만들기'와의 큰 차이점

**노드의 삽입과 삭제**

![node](image/node.png)
* a. 연결 리스트에 4개의 노드가 A -> B -> C -> D 순서대로 나열 되어 있는 상태
    * 이때 배열에 데이터가 들어 있는 순서는 A -> B -> C -> D가 아니라 머리부터 차례대로 C -> A -> D -. B
* b. 연결 리스트의 머리에 노드 E를 삽입한 다음의 상태
    * 이렇게 삽입한 노드는 물리적으로는 '배열의 꼬리 인덱스 위치'에 들어 있는 것 같지만 '연결 리스트의 꼬리'에 추가한 것이 아니라 머리에 삽입한 것
    * 다시 말해 배열에 저장한 데이터의 물리적인 위치(1, 2, 3번째)는 연결 리스트에 저장된 데이터의 논리적인 순서와 다름
* c. 3번째 노드 B를 삭제한 다음의 상태
* 이렇게 삭제를 여러 번하면 배열은 빈 레코드가 너무 많아져 효율이 떨어지므로 비어 있는 레코드를 효율적으로 활용해야 함

## 프리 리스트 구현하기
**프리 리스트**
* 삭제한 레코드를 관리하기 위해 사용하는 자료구조
* 삭제한 여러 레코드를 관리하면 앞에서 발생한 '사용하지 않은 빈 배열'의 문제를 해결할 수 있음
* 프리 리스트는 앞에서 다룬 '커서로 연결 리스트 만들기'와 삭제한 레코드를 관리하기 위한 프리 리스트를 결합해 구현
* 노드 구조체 Node에 추가한 멤버
    * Dnext... 프리 리스트의 다음 포인터(프리 리스트의 다음 노드를 가리키는 다음 커서)
* 연결 리스트를 관리하는 구조체 list에 추가한 멤버
    * deleted... 프리 리스트의 머리 커서(프리 리스트의 머리 노드를 가리키는 커서)
    * max... 배열의 가장 꼬리 쪽에 들어 있는 노드의 레코드 번호

**노드의 삽입에 따라 프리 리스트가 변화하는 모습(1)**

![free](image/free1.png)
* a 연결 리스트에 5개의 노드 A -> B -> C -> E가 순서대로 저장 되어 있음
    * maxㅡ이 값은 7이며, 8번째 레코드는 아직 사용하지 않은 상태
    * 프리 리스트의 머리 노드의 인덱스 3은 연결 리스트용 구조체 list의 멤버 deleted에 저장
* b 연결 리스트 꼬리에 노드 F를 삽입한 이후의 상태
    * 노드를 삽입하는 위치는 새로 정하는 것이 아니라 프리 리스트 3, 1, 5 가운데 머리 노드의 값인 3을 사용
    * 이런 방법으로 프리 리스트에 빈 레코드가 등록된 경우에는 '새 레코드를 지정하고 max의 값을 증가한 다음 해당 레코드에 데이터를 저장하지 않음
    * 따라서 max의 값은 8이 아니라 7인 상태를 유지
    * 만약 삭제한 레코드가 없어 프리 리스트가 비어 있다면 max의 값을 1만큼 증가하고 배열 꼬리의 아직 사용하지 않은 레코드를 사용

**노드의 삽입에 따라 프리 리스트가 변화하는 모습(2)**

![free](image/free2.png)
* c 노드 D를 삭제한 다음의 상태
    * 7번째 레코드에 넣어둔 데이터를 삭제했기 때문에 7을 프리 리스트이 머리 노드로 추가
* 삭제한 레코드를 프리 리스트에 등록하는 함수의 이름은 DeleteIndex이고 노드를 삽입할 때 레코드 번호를 정하는 함수의 이름은 GetIndex
    * 그림 b의 경우 예로 들면 이미 사게한 레코드가 있으므로 GetIndex함수를 실행하면 프리 리스트에 등록된 레코드를 가져와 새 노드를 저장
    * 만약 삭제한 레코드가 없어 프리 리스트가 비어 있다면 max의 값을 1만큼 증가하고 배열 꼬리의 아직 사용하지 않은 레코드를 사용


## 이중 원형 리스트
**원형 리스트**

![won](image/won2.png)
* 선형 리스트의 꼬리 노드가 머리 노드를 가리킴
* 고리 모양으로 나열된 데이터를 저장할 때 알맞은 자료구조
* 원형 리스트와 선형 리스트의 차이점은 꼬리 노드의 다음 노드를 가리키는 포인터가 NULL이 아니라 머리 노드의 포인터값이라는 점
* 원형 리스트는 선형 리스트에서 사용했던 것과 같은 자료형을 사용할 수 있음

**빈 원형 리스트를 판단하는 방법**

![node](image/two1.png)
* 노드가 없는(비어있는) 원형 리스트인지 판단하려면 오른쪽 식을 사용

**노드가 1개인 원형 리스트를 판단하는 방법**

![node](image/two2.png)
* 노드가 1개라면 머리 노드의 다음 포인터는 자기 자신인 머리 노드를 가리킴

**포인터가 머리 노드를 가리키는지 판단하는 방법**

![head](image/two3.png)
* Node *형 변수 p가 리스트에 있는 어떤 노드를 가리키는 경우 p가 가리키고 있는 노드가 원형 리스트의 머리 노드인지 판단하려면 오른쪽 식을 사용

**포인터가 꼬리 노드를 가리키는 지 판단하는 방법**

![tail](image/two4.png)
* Node *형 변수 p가 리스트에 있는 어떤 노드를 가리키는 경우 p가 가리키고 있는 노드가 원형 리스트의 꼬리 노드인지 판단하려면 오른쪽 식을 사용

**이중 연결 리스트(1)**

![이중 연결 리스트](image/two.png)
* 선형 리스트의 가장 큰 단점은 다음 노드는 찾기 쉽지만 앞쪽의 노드를 찾으려면 비용이 든다는 점을 개선한 자료구조
* 각 노드에는 다음 노드에 대한 포인터와 앞쪽의 노드에 대한 포인터가 주어짐
* 그림 8-20처럼 3개의 멤버가 있는 구조체를 사용

**이중 연결 리스트(2)**

![head](image/head2.png)
* 포인터가 머리 노드를 가리키는 지 판단하는 방법
    * 변수 p가 가리키는 노드가 이중 연결 리스트의 머리 노드인지 판단하려면 오른쪽 식을 사용

![tail](image/tail2.png)
* 포인터가 꼬리 노드를 가리키는 지 판단하는 방법
    * p가 가리키고 잇는 노드가 꼬리 노드인지 판단하려면 오른쪽 식을 사용

**원형 이중 연결 리스트**

![연결 리스트](image/won.png)
* 앞에서 공부한 두 가지의 개념을 합함

**노드를 나타내는 구조체Dnode**

![Dnode](image/Dnode.png)
* Dnode는 그림 8-20의 이중 연결 리스트의 노드에서 사용
    * data... 데이터
    * prev... 앞쪽 노드에 대한 포인터
    * next... 다음 노드에 대한 포인터

**원형 이중 연결 리스트를 관리하는 구조체 Dlist**
* 선형 리스트의 list와 마찬가지로 머리 노드에 대한 포인터와 선택한 노드에 대한 포인터를 가지고 있음

**노드를 생성하는 AllocDnode 함수**
* Dnode형 객체를 생성하고 해당 객체의 포인터를 반환하는 함수

**노드의 멤버값을 설정하는 SetDnode 함수**
* Dnode형 객체의 멤버값을 설정
* 첫 번째 매개변수 n에 전달받은 Dnode형 객체 포인터를 통해 멤버값을 설정
* 객체 멤버인 data, prev, next에 두 번째 매개변수가 가리키는 객체의 값, 세 번째 매개변수와 네 번째 매개변수의 포인터값을 대입

**원형 이중 연결 리스트를 초기화하는 Initialize 함수**

![Initialize](image/Initialize.png)
* 텅 비어 있는 상태의 원형 이중 연결 리스트를 만드는 함수
* 리스트의 머리 부분에 더미 노드가 만들어짐(노드의 삽입, 삭제를 원만히 수행하기 위해 필요)
* 3개 포인터가 가리키는 대상 모두를 리스트의 앞쪽에 있는 더미라고 함
    * 머리 포인터 list -> head가 가리키는 대상
    * 더미 노드의 앞쪽 포인터 list -> head -> prev가 가리키는 대상
    * 더미 노드의 다음 포인터 list -> head -> next가 가리키는 대상

**리스트가 비어 있는지 검사하는 IsEmpty 함수**
* 더미 노드의 뒤쪽 포인터 list -> head -> next가 자신의 더미 노드인 list -> head를 가리키는 지를 판단
* 함수의 반환값은 리스트가 비어 있는 경우에는 1(아닌 경우에는 0)

**선택한 노드의 데이터를 출력하는 PrintCurrent/PrintLnCurrent 함수**
* PrintCurrent함수는 list -> crnt가 가리키는 노드의 데이터를 PrintMember함수를 이용해 출력
* 리스트가 비어 있는 경우에는 '선택한 노드가 없습니다.'라는 메시지를 출력

**노드를 검색하는 Search 함수(1)**

![Search](image/Search1.png)
* 머리 노드부터 뒤쪽 포인터를 이용해 순서대로 스캔
* 머리 노드는 더미 노드가 아니라 더미 노드의 다음 노드
* 그림 8-24에서 머리 포인터 list -> head가 가리키는 더미 노드의 뒤쪽 포인터가 가리키는 노드 A가 진짜 머리 노드
* 따라서 검색을 시작하는 노드의 위치는 list -> head가 가리키는 노드가 아닌 list -> next가 가리키는 노드

**노드를 검색하는 Search 함수(2)**

![Search](image/Search2.png)
* Node *형의 포인터 a, b, c, d, e가 각각 노드 A, 노드 B, ..., 노드 E를 순서대로 가리키는 경우 각 노드를 가리키는 식은 오른쪽 표와 같음(각각의 식은 노드 자신을 의미)
* Search함수는 while문으로 노드를 하나씩 스캔하는 과정에서 비교 함수인 compare함수를 사용
    * compare함수로 비교한 결과가 0이면 검색 성공이며 찾은 노드에 대한 포인터인 ptr을 반환
    * 이때 crnt는 찾은 노드(ptr)를 가리키도록 설정
* 노드를 찾지 못하고 한 바퀴 돌아 다시 더미 노드로 돌아오면(ptr이 head와 같으면) 검색에 실패한 것이므로 while문을 종료하고 NULL을 반환

**노드를 검색하는 Search 함수(3)**

![Search](image/Search3.png)
* 빈 리스트를 검색하는 경우라 가정하고 이 함수가 정말 검색에 실패하는지(NULL을 반환하는지) 그림 8-25를 통해 확인
* ptr에 대입하는 list -> head -> next 값은 더미 노드에 대한 포인터
* 다시말해 ptr은 list -> head와 같은 값
* 그러면 while문의 제어신 ptr != list -> head가 성립되지 않기 때문에 while문은 실행되지 않고 바로 NULL을 반환하며 함수가 종료

**모든 노드를 거꾸로 출력하는 PrintReverse 함수**

![PrintReverse](image/PrintReverse.png)
* list -> head -> prev부터 스캔하기 시작해 앞쪽 포인터를 찾아가며 각 노드의 데이터를 출력
    * b는 1 -> 2 -> 3...의 순서로 포인터를 찾아감
* 다시 head로 돌아오면 스캔을 종료
    * 6을 찾아가면 다시 더미 노드로 돌아온 것과 같으므로 스캔을 종료

**선택한 노드의 다음으로 진행시키는 Next 함수**
* 리스트가 비어있지 않고 선택한 노드의 다음 노드가 있는 경우에만 동작
* 선택한 노드가 다음 노드로 진행하는 데 성공하면 1, 실패하면 0을 반환

**선택한 노드의 앞쪽으로 진행시키는 Prev 함수**
* 리스트가 비어 있지 않고 선택한 노드의 앞쪽 노드가 있는 경우에만 동작
* 선택한 노드가 앞쪽 노드로 되돌아가는 데 성공하면 1, 실패하면 0을 반환

**바로 다음에 노드를 삽입하는 InsertAfter 함수(1)**

![InsertAfter](image/InsertAfter1.png)
* 포인터 p가 가리키는 노드의 바로 다음에 노드를 삽입
* 그림 8-27에서 노드를 삽입한 위치는 p가 가리키는 노드와 p -> next가 가리키는 노드의 사이
    * 1. 새로 삽입할 노드 D를 만들고 만든 노드의 앞쪽 포인터가 가리키는 노드는 B, 뒤쪽 포인터가 가리키는 노드는 C로 설정
    * 2. 노드 B의 뒤쪽 포인터 p -> next와 노드 C의 앞쪽 포인터 p -> next -> prev 모두 새로 삽입한 노드를 가리키도록 업데이트
    * 3. 선택한 포인터 list -> crnt가 삽입한 노드를 가리키도록 업데이트

**바로 다음에 노드를 삽입하는 InsertAfter 함수(2)**

![InsertAfter](image/InsertAfter2.png)
* 리스트 머리에 더미 노드가 있어 '비어 있는 리스트에 삽입하는 경우'와 '리스트 머리에 삽입하는 경우'를 따로 처리하지 않아도 됨
* 그림 8-28에는 더미 노드만 있는 빈 리스트에 노드 A를 삽입하는 데 삽입하기 전에 crnt, head는 모두 더미 노드를 가리키고 있음
* 삽입 과정
    * 1. 만든 노드의 앞쪽 포인터와 뒤쪽 포인터는 더미 노드를 가리킴
    * 2. 더미 노드의 뒤쪽 포인터와 앞쪽 포인터가 가리키는 노드는 A
    * 3. 선택한 노드가 가리키는 노드는 삽입한 노드

**머리에 노드를 삽입하는 InsertFront 함수**
* 머리 노드의 바로 뒤에 삽입
* list -> head가 가리키는 더미 노드 뒤에 노드를 삽입

**꼬리에 노드를 삽입하는 InserRear 함수**
* 꼬리 노드의 바로 뒤 = 더미 노드의 바로 앞에 삽입
* list -> head -> prev가 가리키는 꼬리 노드 두에 노드를 삽입

**노드를 삭제하는 Remove 함수**

![Remove](image/remove.png)
* 포인터 p가 가리키는 노드를 삭제하는 함수
* 삭제 과정
    * 1. 노드 A의 뒤쪽 포인터 p -> prev -> next가 가리키는 노드가 C(p -> next)가 되도록 업데이트
    * 2. 노드 C의 앞쪽 포인터 p -> next -> prev가 가리키는 노드가 A(p -> prev)가 되도록 업데이트하고 p가 가리키는 메모리 영역을 해제
    * 3. 선택한 노드가 삭제한 노드의 앞쪽 노드 A를 가리킬 수 있도록 crnt를 업데이트

**머리 노드를 삭제하는 RemoverFront 함수**
* Remove 함수를 사용해 포인터 list -> head -> next가 가리키는 머리 노드를 삭제
* 이때 더미 노드는 삭제하면 안 됨
* 따라서 list -> head가 가리키는 더미 노드가 아닌 그 다음의 노드 list -> head -> next를 삭제

**꼬리 노드를 삭제하는 RemoveRear 함수**
* Remove 함수를 사용해서 포인터 list -> head -> prev가 가리키는 꼬리 노드를 삭제

**선택한 노드를 삭제하는 RemoveCurrent 함수**
* Remove 함수를 사용해서 포인터 list -> crnt가 가리키는 노드를 삭제

**모든 노드를 삭제하는 Clear 함수**
* 더미 노드를 제외하고 모든 노드를 삭제하는 함수
* 리스트가 텅 빌 때까지 RemoveFront 함수를 사용해 머리 노드의 삭제를 반복
* 선택한 포인터 list -> crnt가 가리키는 노드는 더미 노드 list -> head로 업데이트

**원형 이중 연결 리스트를 종료하는 Terminate 함수**
* 먼저 Clear 함수를 호출해 모든 노드를 삭제하고 더미 노드의 메모리 영역도 해제
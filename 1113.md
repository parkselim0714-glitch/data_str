# 202530212 박 세림

# 11월 06일 대림테크페어
![대림테크](daelim1.jpg)
![대림테크](daelim2.jpg)

# 11월 13일 강의

# 11월 20일 강의

## 리스트
**리스트**
* 데이터를 순서대로 나열해 놓은 자료구조
* 가장 단순한 구조를 가진 리스트를 선형 리스트 또는 연결 리스트라고 함
* 그림 8-2를 보면 A부터 F까지 6개의 데이터가 순서대로 나열되어 있고 각각의 데이터가 화살표로 연결되어 있음
* 각 데이터의 연결 관계를 '이야기 전달하기 게임'에 비유할 수 있음
* 즉, 한 사람을 건너뛰어 이야기를 전달할 수 없음

## 노드
**노드**
* 리스트의 각 요소
* 각각의 노드는 데이터와 다음 노드를 가리키는 포인터를 가지고 잇음
* 처음과 끝에 있는 노드는 특별히 각각 머리 노드, 꼬리 노드라고 함
* 하나의 노드에 대해 바로 앞에 있는 노드를 앞쪽 노드, 바로 뒤에 있는 노드를 다음 노드라고 함

## 선형 리스트
**다음 노드 꺼내기**
* 배열의 각 요소에는 연락할 순서대로 데이터가 저장
* 전화를 걸기 위해 필요한 '다음 노드 꺼내기'는 1만큼 큰 인덱스를 갖는 요소에 접근하면 됨

**노드의 삽입과 삭제**
* 회원번호가 55인 회원이 새로 가입했고 이 회원의 정보를 회원번호 12, 33 사이에 삽입하려면 [b]와 같이 삽입 요소 다음의 모든 요소를 하나씩 뒤로 밀어야 함
* 삭제하는 경우도 모든 요소를 뒤로 밀거나 앞으로 당겨야 함
* 이런 작업이 필요하기 때문에 배열로 구현한 선형 리스트는 쌓이는 데이터의 크기를 미리 알아야 함
* 데이터의 삽입, 삭제에 따라 데이터를 모두 옮겨야 하기 때문에 효율이 좋지 않음

## 포인터를 이용한 연결 리스트
**노드용 구조체**
* 노드용 객체를, 연결 리스트에 데이터를 삽입할 때 만들고 삭제할 때 없애면, 앞에서 제시한 데이터를 밀고 당기는 문제를 해결할 수 있음
* 노드용 구조체 Node는 다음의 두 멤버, data와 next로 구성
    * data... 데이터(Member형)
    * next... 다음 노드에 대한 포인터(자기 자신과 같은 구조체형을 가리키는 포인터형)
* 이와 같이 자기 자신과 같은 자료형의 개게를 가리키는 데이터가 내부에 포함
* 이러한 자료구조를 자기 참조형이라고 함

**연결 리스트를 고나리하는 구조체 list**
* 노드용 구조체 Node를 사용한 연결 리스트를 나타낸 것
* List는 두 멤버로 구성되어 있고 모두 Node에 대한 포인터 자료형을 가지고 있음
* head는 연결 리스트의 머리 노드를 가리키는 머리 포인터이고, crnt는 현재 선택한 노드를 가리키는 선택 포인터
* '검색'한 노드를 선택하고 '삭제'하는 용도로 사용
* 연결 리스트를 관리하는 구조체 list는 2개의 포인터만 가짐
* 그림 8-5에 나타낸 A~D의 각 노드는 Node형 객체이지 List의 일부는 아님
* **crnt: 현재 선택한 노드를 가리키는 포인터(커서)**

**노드를 만드는 AllocNode 함수**
* Node형 객체를 만들고 만든 객체의 포인터를 반환

**노드의 멤버값을 성정하는 SetNode 함수**
* Node형 객체의 두 멤버(data, next)의 값을 설정하는 함수
* 첫 번째 매개변수 n으로 전달받은 포인터가 가리키는 Node형 객체에 x가 가리키는 값을 대입하고 n의 next에 세 번째 매개변수로 전달받은 next를 대입

**연결 리스트를 초기화하는 Initialize 함수**
* 머리 노드를 가리키는 list -> head에 NULL 값을 대입하여 노드가 하나도 없는 텅 빈 연결 리스트를 만듦

**a. 연결 리스트가 비어 있는 지 판단하는 방법**
* 빈 연결 리스트는 노드가 하나도 없는 상태이기 때문에 head가 가리키는 노드도 없음

**b. 노드가 1개인 연결 리스트를 판단하는 방법**
* 머리 포인터 list -> head가 가리키는 노드는 머리 노드 A
* 머리 노드 A는 리스트의 꼬리 노드이기도 하므로 next값은 널

**c. 노드가 2개인 연결 리스트를 판단하는 방법**
* 머리 노드는 A, 두 번째 노드이자 꼬리 노드는 B
* 머리 포인터 list -> head가 가리키는 노드 A의 뒤쪽 포인터 next는 노드 B를 가리킴
* 꼬리 노드 B의 뒤쪽 포인터 next는 NULL값을 가짐

**포인터가 머리 노드를 가리키는 지 판단하는 방법**
* 자료형이 Node *형인 변수 p는 리스트의 노드 중 하나를 가리킴
* 변수 p가 가리키는 노드가 연결 리스트의 머리 노드인지 판단하는 방법은 밑과 같음

**포인터가 꼬리 노드를 가리키는 지 판단하는 방법**
* 변수 p가 가리키는 노드가 연결 리스트의 꼬리 노드인지 판단하는 방법은 밑과 같음

**검색을 수행하는 Search 함수(1)**
* 어떤 조건을 만족하는 노드를 검색
* 전달받는 매개변수
    * list... 검색 대상인 연결 리스트를 가리키는 포인터
    * x... 검색하는 키값을 저장한 회원 데이터를 가리키는 포인터
    * compare... 두 번째 매개변수 x가 가리키는 객체와, 연결 리스트의 노드 안의 데이터를 비교하는 함수를 가리키는 포인터로 이 비교 함수는 검새겡 성공하면 0을 반환
* 이 함수가 반환하는 값은 찾은 노드에 대한 포인터이고 만약 검색에 실패하면 널을 반환

**검색을 수행하는 Search 함수(2)**
* 검색에 사용하는 알고리즘은 선형 검색이고, 그림 8-7처럼 검색할 노드를 만날 때까지 머리 노드부터 스캔
* 노드 스캔은 아래의 조건 중 하나만 성립하면 종료
    * 검색 조건을 만족하는 노드를 찾지 못하고 꼬리 노드를 지나가기 직전인 경우
    * 검색 조건을 만족하는 노드를 찾은 경우

**검색 과정(1)**
* 1. 스캔하고 있는 노드를 가리키는 포인터 ptr을 list -> head로 초기화
    * 그림 a와 같이 ptr이 가리키는 노드는 list -> head가 가리키고 있는 머리 노드인 A
* 2. 종료 조건 1을 먼저 판단
    * ptr 값이 널이 아니면 루프 본문의 3, 4를 실행
    * ptr 값이 널이면 스캔할 노드가 없음을 의미하기 때문에 while 문을 빠져나와 5로 진행

**검색 과정(2)**
* 3. 종료 조건 2를 판단하기 위해 스캔하고 있는 노드의 데이터(ptr -> data)와 x가 가리키는 데이터를 compare 함수로 비교
    * compare 함수는 검색에 성공하면 0을 반환
    * 즉, 종료 조건 2가 성립
    * 곧바로 포인터 list -> crnt에 ptr을 대입하고 찾은 노드에 대한 포인터인 ptr을 반환
* 4. ptr에 ptr -> next를 대입
    * 이렇게 하면 ptr이 다음 노드를 가리키기 때문에 게속해서 스캔할 수 있음
* 5. 검색에 실패하면 널을 반환

**머리에 노드를 삽입하는 InsertFront 함수(1)**
* 1. 삽입 전의 머리 노드 A에 대한 머리 포인터를 ptr에 대입
* 2. 삽입할 노드 G를 AllocNode 함수로 만들고 만든 노드 G를 가리키도록 머리 포인터 list -> head를 업데이트
* 3. SetNode 함수를 호출하여 값을 설정
    * 이때 삽입한 다음 머리 노드의 다음을 가리키는 포인터의 값을 ptr(삽입하기 전의 머리 노드 A)로 업데이트

**꼬리에 노드를 삽입하는 InsertRear 함수(2)**
* 4. 꼬리 노드를 찾음
    * 머리 노드를 가리키도록 초기화한 ptr이 가리키는 노드를, 계속해서 다음 노드를 가리키도록 업데이트하는 과정을 반복
    * 이렇게 반복하면 노드를 처음부터 차례로 스캔할 수 있음
    * ptr -> next가 가리키는 노드가 널이 되면 while 문을 종료
    * 이때 ptr이 가리키는 노드는 꼬리 노드 F

* 5. 삽입할 노드 G를 AllocNode 함수로 만듦
    * 그리고 삽입하기 전의 꼬리 노드 F의 다음 포인터 ptr -> next가 가리키는 노드에, 삽입한 다음의 꼬리 노드 G를 대입
    * 그런 다음 SetNode 함수를 호출해 앞에서 만든 노드 G의 값을 설정
    * 이때 노드 G의 다음 노드에 널을 대입

**머리 노드를 삭제하는 RemoveFront 함수**
* 리스트가 비어 있지 않은 경우(list -> head != NULL)에만 삭제를 실행
* 삭제하기 전의 머리 노드 Aㅡ이 메모리 영역을 해제
* 머리 노드에 대한 포인터 list -> head -> next를 대입하여 머리 노드에 대한 포인터가 노드 B를 가리키도록 업데이트
* 만약 리스트에 노드가 1개만 있어도 오류 없이 삭제할 수 있고 리스트는 빈 상태가 됨
* 삭제하기 전의 머리 노드는 꼬리 노드이기 때문에 다음 노드를 가리키는 list -> head -> next의 값은 널
* 널을 list -> head에 대입하면 리스트는 빈 상태가 됨

**꼬리 노드를 삭제하는 RemoveFront 함수**
* 리스트에 노드가 1개뿐인지(list -> next == NULL) 아니면 2개 이상인지에 따라 서로 다른 작업을 수행
    * 1. 리스트에 노드가 1개만 있는 경우: 머리 노드를 삭제하는 것과 같아 RemoveFront 함수로 처리
    * 2. 리스트에 노드가 2개 이상 있는 경우: 그림 8-12의 과정
* 1. '꼬리 노드'와 '꼬리 노드로 부터 두 번째 노드'를 찾음
    * 스캔하는 방법은 InsertRear 함수와 비슷하지만 현재 스캔하고 있는 노드의 '앞에 있는 노드'를 가리키는 변수 pre를 추가한 점이 다름
    * while문이 종료되면 pre는 노드 E를 , ptr은 노드 F를 가리킴
* 2. 꼬리 노드부터 두 번째 노드 E의 다음을 가리키는 포인터에 널을 대입하고 꼬리 노드 F의 메모리 영역을 해제

**선택한 노드를 삭제하는 RemoveCurrent 함수(1)**
* 현재 선택한 포인터(list -> crnt)가 가리키는 노드를 삭제하는 함수
* 삭제할 노드가 머리 노드인지 아닌지에 따라 다음의 작업을 수행
    * 1. crnt가 머리 노드인 경우: 머리 노드를 삭제하면 되므로 RemoveFront 함수로 처리
    * 2. crnt가 머리 노드가 아닌 경우: 그림 8-13의 과정

**리스트의 모드 노드를 출력하는 print 함수**
* 머리 노드부터 꼬리 노드까지 포인터 ptr이 가리키는 데이터를 출력

**연결 리스트를 종료하는 Terminate 함수**
* 모든 노드를 삭제하는 Clear 함수를 호출

**각 함수를 실행한 후의 crnt 값**
## 커서로 연결 리스트 만들기
**커서를 사용한 연결 리스트(1)**
* 프로그램 실행 중에 데이터의 개수가 크게 바뀌지 않고 데이터 개수의 최댓값을 미리 알 수 있다고 가정하면 그림 8-14처럼 배열을 사용해 효율적으로 연결 리스트를 운용할 수 있음
* 배열의 커서에 해당하는 값은 다음 노드에 대한 포인터가 아니라 다음 노드가 들어 있는 요소의 인덱스에 대한 값
    * 여기서 포인터 역할을 하는 인덱스를 커서라고 함

**커서를 사용한 연결 리스트(2)**
* 꼬리 노드의 커서는 배열의 인덱스로는 있을 수 없는 값인 - 1
* 머리 노드를 나타내는 head도 커서이기 때문에 머리 노드 A가 드렁 있는 곳인 인덱스 1이 head의 값이 됨
* 이와 같은 방법을 사용하면 노드의 삽입, 삭제 시 요소를 옮길 필요가 없음
* 예를 들어, 그림 8-14의 연결 리스트의 머리에 노드 G를 삽입하면 그림 8-15와 같은 상태가 됨
* head를 1에서 6으로 업데이트하고 노드 G의 커서에 1을 대입하면 됨
* 이러한 점이 앞서 08-1절에서 살펴본 '배열로 선형 리스트 만들기'와의 큰 차이점

**노드의 삽입과 삭제**
* a. 연결 리스트에 4개의 노드가 A -> B -> C -> D 순서대로 나열 되어 있는 상태
    * 이때 배열에 데이터가 들어 있는 순서는 A -> B -> C -> D가 아니라 머리부터 차례대로 C -> A -> D -. B
* b. 연결 리스트의 머리에 노드 E를 삽입한 다음의 상태
    * 이렇게 삽입한 노드는 물리적으로는 '배열의 꼬리 인덱스 위치'에 들어 있는 것 같지만 '연결 리스트의 꼬리'에 추가한 것이 아니라 머리에 삽입한 것
    * 다시 말해 배열에 저장한 데이터의 물리적인 위치(1, 2, 3번째)는 연결 리스트에 저장된 데이터의 논리적인 순서와 다름
* c. 3번째 노드 B를 삭제한 다음의 상태
* 이렇게 삭제를 여러 번하면 배열은 빈 레코드가 너무 많아져 효율이 떨어지므로 비어 있는 레코드를 효율적으로 활용해야 함

## 프리 리스트 구현하기
**프리 리스트**
* 삭제한 레코드를 관리하기 위해 사용하는 자료구조
* 삭제한 여러 레코드를 관리하면 앞에서 발생한 '사용하지 않은 빈 배열'의 문제를 해결할 수 있음
* 프리 리스트는 앞에서 다룬 '커서로 연결 리스트 만들기'와 삭제한 레코드를 관리하기 위한 프리 리스트를 결합해 구현
* 노드 구조체 Node에 추가한 멤버
    * Dnext... 프리 리스트의 다음 포인터(프리 리스트의 다음 노드를 가리키는 다음 커서)
* 연결 리스트를 관리하는 구조체 list에 추가한 멤버
    * deleted... 프리 리스트의 머리 커서(프리 리스트의 머리 노드를 가리키는 커서)
    * max... 배열의 가장 꼬리 쪽에 들어 있는 노드의 레코드 번호

**노드의 삽입에 따라 프리 리스트가 변화하는 모습(1)**
* a 연결 리스트에 5개의 노드 A -> B -> C -> E가 순서대로 저장 되어 있음
    * maxㅡ이 값은 7이며, 8번째 레코드는 아직 사용하지 않은 상태
    * 프리 리스트의 머리 노드의 인덱스 3은 연결 리스트용 구조체 list의 멤버 deleted에 저장
* b 연결 리스트 꼬리에 노드 F를 삽입한 이후의 상태
    * 노드를 삽입하는 위치는 새로 정하는 것이 아니라 프리 리스트 3, 1, 5 가운데 머리 노드의 값인 3을 사용
    * 이런 방법으로 프리 리스트에 빈 레코드가 등록된 경우에는 '새 레코드를 지정하고 max의 값을 증가한 다음 해당 레코드에 데이터를 저장하지 않음
    * 따라서 max의 값은 8이 아니라 7인 상태를 유지
    * 만약 삭제한 레코드가 없어 프리 리스트가 비어 있다면 max의 값을 1만큼 증가하고 배열 꼬리의 아직 사용하지 않은 레코드를 사용

**노드의 삽입에 따라 프리 리스트가 변화하는 모습(2)**
* c 노드 D를 삭제한 다음의 상태
    * 7번째 레코드에 넣어둔 데이터를 삭제했기 때문에 7을 프리 리스트이 머리 노드로 추가
* 삭제한 레코드를 프리 리스트에 등록하는 함수의 이름은 DeleteIndex이고 노드를 삽입할 때 레코드 번호를 정하는 함수의 이름은 GetIndex
    * 그림 b의 경우 예로 들면 이미 사게한 레코드가 있으므로 GetIndex함수를 실행하면 프리 리스트에 등록된 레코드를 가져와 새 노드를 저장
    * 만약 삭제한 레코드가 없어 프리 리스트가 비어 있다면 max의 값을 1만큼 증가하고 배열 꼬리의 아직 사용하지 않은 레코드를 사용


## 이중 원형 리스트
**원형 리스트**
* 선형 리스트의 꼬리 노드가 머리 노드를 가리킴
* 고리 모양으로 나열된 데이터를 저장할 때 알맞은 자료구조
* 원형 리스트와 선형 리스트의 차이점은 꼬리 노드의 다음 노드를 가리키는 포인터가 NULL이 아니라 머리 노드의 포인터값이라는 점
* 원형 리스트는 선형 리스트에서 사용했던 것과 같은 자료형을 사용할 수 있음

**빈 원형 리스트를 판단하는 방법**
* 노드가 없는(비어있는) 원형 리스트인지 판단하려면 오른쪽 식을 사용

**노드가 1개인 원형 리스트를 판단하는 방법**
* 노드가 1개라면 머리 노드의 다음 포인터는 자기 자신인 머리 노드를 가리킴

**포인터가 머리 노드를 가리키는지 판단하는 방법**
* Node *형 변수 p가 리스트에 있는 어떤 노드를 가리키는 경우 p가 가리키고 있는 노드가 원형 리스트의 머리 노드인지 판단하려면 오른쪽 식을 사용

**포인터가 꼬리 노드를 가리키는 지 판단하는 방법**
* Node *형 변수 p가 리스트에 있는 어떤 노드를 가리키는 경우 p가 가리키고 있는 노드가 원형 리스트의 꼬리 노드인지 판단하려면 오른쪽 식을 사용

**이중 연결 리스트(1)**
* 선형 리스트의 가장 큰 단점은 다음 노드는 찾기 쉽지만 앞쪽의 노드를 찾으려면 비용이 든다는 점을 개선한 자료구조
* 각 노드에는 다음 노드에 대한 포인터와 앞쪽의 노드에 대한 포인터가 주어짐
* 그림 8-20처럼 3개의 멤버가 있는 구조체를 사용

**이중 연결 리스트(2)**
* 포인터가 머리 노드를 가리키는 지 판단하는 방법
    * 변수 p가 가리키는 노드가 이중 연결 리스트의 머리 노드인지 판단하려면 오른쪽 식을 사용


* 포인터가 꼬리 노드를 가리키는 지 판단하는 방법
    * p가 가리키고 잇는 노드가 꼬리 노드인지 판단하려면 오른쪽 식을 사용

**원형 이중 연결 리스트**
* 앞에서 공부한 두 가지의 개념을 합함

**노드를 나타내는 구조체Dnode**
* Dnode는 그림 8-20의 이중 연결 리스트의 노드에서 사용
    * data... 데이터
    * prev... 앞쪽 노드에 대한 포인터
    * next... 다음 노드에 대한 포인터

**원형 이중 연결 리스트를 관리하는 구조체 Dlist**
* 선형 리스트의 list와 마찬가지로 머리 노드에 대한 포인터와 선택한 노드에 대한 포인터를 가지고 있음

**노드를 생성하는 AllocDnode 함수**
* Dnode형 객체를 생성하고 해당 객체의 포인터를 반환하는 함수

**노드의 멤버값을 설정하는 SetDnode 함수**
* Dnode형 객체의 멤버값을 설정
* 첫 번째 매개변수 n에 전달받은 Dnode형 객체 포인터를 통해 멤버값을 설정
* 객체 멤버인 data, prev, next에 두 번째 매개변수가 가리키는 객체의 값, 세 번째 매개변수와 네 번째 매개변수의 포인터값을 대입

**원형 이중 연결 리스트를 초기화하는 Initialize 함수**
* 텅 비어 있는 상태의 원형 이중 연결 리스트를 만드는 함수
* 리스트의 머리 부분에 더미 노드가 만들어짐(노드의 삽입, 삭제를 원만히 수행하기 위해 필요)
* 3개 포인터가 가리키는 대상 모두를 리스트의 앞쪽에 있는 더미라고 함
    * 머리 포인터 list -> head가 가리키는 대상
    * 더미 노드의 앞쪽 포인터 list -> head -> prev가 가리키는 대상
    * 더미 노드의 다음 포인터 list -> head -> next가 가리키는 대상

**리스트가 비어 있는지 검사하는 IsEmpty 함수**
* 더미 노드의 뒤쪽 포인터 list -> head -> next가 자신의 더미 노드인 list -> head를 가리키는 지를 판단
* 함수의 반환값은 리스트가 비어 있는 경우에는 1(아닌 경우에는 0)

**선택한 노드의 데이터를 출력하는 PrintCurrent/PrintLnCurrent 함수**
* PrintCurrent함수는 list -> crnt가 가리키는 노드의 데이터를 PrintMember함수를 이용해 출력
* 리스트가 비어 있는 경우에는 '선택한 노드가 없습니다.'라는 메시지를 출력

**노드를 검색하는 Search 함수(1)**
* 머리 노드부터 뒤쪽 포인터를 이용해 순서대로 스캔
* 머리 노드는 더미 노드가 아니라 더미 노드의 다음 노드
* 그림 8-24에서 머리 포인터 list -> head가 가리키는 더미 노드의 뒤쪽 포인터가 가리키는 노드 A가 진짜 머리 노드
* 따라서 검색을 시작하는 노드의 위치는 list -> head가 가리키는 노드가 아닌 list -> next가 가리키는 노드

**노드를 검색하는 Search 함수(2)**
* Node *형의 포인터 a, b, c, d, e가 각각 노드 A, 노드 B, ..., 노드 E를 순서대로 가리키는 경우 각 노드를 가리키는 식은 오른쪽 표와 같음(각각의 식은 노드 자신을 의미)
* Search함수는 while문으로 노드를 하나씩 스캔하는 과정에서 비교 함수인 compare함수를 사용
    * compare함수로 비교한 결과가 0이면 검색 성공이며 찾은 노드에 대한 포인터인 ptr을 반환
    * 이때 crnt는 찾은 노드(ptr)를 가리키도록 설정
* 노드를 찾지 못하고 한 바퀴 돌아 다시 더미 노드로 돌아오면(ptr이 head와 같으면) 검색에 실패한 것이므로 while문을 종료하고 NULL을 반환

**노드를 검색하는 Search 함수(3)**
* 빈 리스트를 검색하는 경우라 가정하고 이 함수가 정말 검색에 실패하는지(NULL을 반환하는지) 그림 8-25를 통해 확인
* ptr에 대입하는 list -> head -> next 값은 더미 노드에 대한 포인터
* 다시말해 ptr은 list -> head와 같은 값
* 그러면 while문의 제어신 ptr != list -> head가 성립되지 않기 때문에 while문은 실행되지 않고 바로 NULL을 반환하며 함수가 종료

**모든 노드를 거꾸로 출력하는 PrintReverse 함수**
* list -> head -> prev부터 스캔하기 시작해 앞쪽 포인터를 찾아가며 각 노드의 데이터를 출력
    * b는 1 -> 2 -> 3...의 순서로 포인터를 찾아감
* 다시 head로 돌아오면 스캔을 종료
    * 6을 찾아가면 다시 더미 노드로 돌아온 것과 같으므로 스캔을 종료

**선택한 노드의 다음으로 진행시키는 Next 함수**
* 리스트가 비어있지 않고 선택한 노드의 다음 노드가 있는 경우에만 동작
* 선택한 노드가 다음 노드로 진행하는 데 성공하면 1, 실패하면 0을 반환

**선택한 노드의 앞쪽으로 진행시키는 Prev 함수**
* 리스트가 비어 있지 않고 선택한 노드의 앞쪽 노드가 있는 경우에만 동작
* 선택한 노드가 앞쪽 노드로 되돌아가는 데 성공하면 1, 실패하면 0을 반환

**바로 다음에 노드를 삽입하는 InsertAfter 함수(1)**
* 포인터 p가 가리키는 노드의 바로 다음에 노드를 삽입
* 그림 8-27에서 노드를 삽입한 위치는 p가 가리키는 노드와 p -> next가 가리키는 노드의 사이
    * 1. 새로 삽입할 노드 D를 만들고 만든 노드의 앞쪽 포인터가 가리키는 노드는 B, 뒤쪽 포인터가 가리키는 노드는 C로 설정
    * 2. 노드 B의 뒤쪽 포인터 p -> next와 노드 C의 앞쪽 포인터 p -> next -> prev 모두 새로 삽입한 노드를 가리키도록 업데이트
    * 3. 선택한 포인터 list -> crnt가 삽입한 노드를 가리키도록 업데이트

**바로 다음에 노드를 삽입하는 InsertAfter 함수(2)**
* 리스트 머리에 더미 노드가 있어 '비어 있는 리스트에 삽입하는 경우'와 '리스트 머리에 삽입하는 경우'를 따로 처리하지 않아도 됨
* 그림 8-28에는 더미 노드만 있는 빈 리스트에 노드 A를 삽입하는 데 삽입하기 전에 crnt, head는 모두 더미 노드를 가리키고 있음
* 삽입 과정
    * 1. 만든 노드의 앞쪽 포인터와 뒤쪽 포인터는 더미 노드를 가리킴
    * 2. 더미 노드의 뒤쪽 포인터와 앞쪽 포인터가 가리키는 노드는 A
    * 3. 선택한 노드가 가리키는 노드는 삽입한 노드

**머리에 노드를 삽입하는 InsertFront 함수**
* 머리 노드의 바로 뒤에 삽입
* list -> head가 가리키는 더미 노드 뒤에 노드를 삽입

**꼬리에 노드를 삽입하는 InserRear 함수**
* 꼬리 노드의 바로 뒤 = 더미 노드의 바로 앞에 삽입
* list -> head -> prev가 가리키는 꼬리 노드 두에 노드를 삽입

**노드를 삭제하는 Remove 함수**
* 포인터 p가 가리키는 노드를 삭제하는 함수
* 삭제 과정
    * 1. 노드 A의 뒤쪽 포인터 p -> prev -> next가 가리키는 노드가 C(p -> next)가 되도록 업데이트
    * 2. 노드 C의 앞쪽 포인터 p -> next -> prev가 가리키는 노드가 A(p -> prev)가 되도록 업데이트하고 p가 가리키는 메모리 영역을 해제
    * 3. 선택한 노드가 삭제한 노드의 앞쪽 노드 A를 가리킬 수 있도록 crnt를 업데이트

**머리 노드를 삭제하는 RemoverFront 함수**
* Remove 함수를 사용해 포인터 list -> head -> next가 가리키는 머리 노드를 삭제
* 이때 더미 노드는 삭제하면 안 됨
* 따라서 list -> head가 가리키는 더미 노드가 아닌 그 다음의 노드 list -> head -> next를 삭제

**꼬리 노드를 삭제하는 RemoveRear 함수**
* Remove 함수를 사용해서 포인터 list -> head -> prev가 가리키는 꼬리 노드를 삭제

**선택한 노드를 삭제하는 RemoveCurrent 함수**
* Remove 함수를 사용해서 포인터 list -> crnt가 가리키는 노드를 삭제

**모든 노드를 삭제하는 Clear 함수**
* 더미 노드를 제외하고 모든 노드를 삭제하는 함수
* 리스트가 텅 빌 때까지 RemoveFront 함수를 사용해 머리 노드의 삭제를 반복
* 선택한 포인터 list -> crnt가 가리키는 노드는 더미 노드 list -> head로 업데이트

**원형 이중 연결 리스트를 종료하는 Terminate 함수**
* 먼저 Clear 함수를 호출해 모든 노드를 삭제하고 더미 노드의 메모리 영역도 해제

## 트리
**트리 관련 용어(1)**
* 트리를 구성하는 요소는 노드(node)와 가지(edge)
* 각각의 노드는 가지를 통해 다른 노드와 연결되어 있음
* 루트(root)
    * 트리의 가장 윗부분에 위치하는 노드
    * 하나의 트리에는 하나의 루트가 있음
    * 그림을 거꾸로 보면 나무 모양과 비슷함
* 리프(leaf)
    * 트리의 가장 아랫부분에 위치하는 노드
    * '가장 아래에 위치한다'라는 말은 물리적으로 가장 아랫부분에 위치한다는 의미가 아니라 더 이상 뻗어나갈 수 없는 마지막에 노드가 위치한다는 의미
* 안쪽 노드
    * 루트를 포함하여 리프을 제외한 노드

**트리 관련 용어(2)**
* 자식 child
    * 어떤 노드로부터 가지로 연결된 아래쪽 노드
    * 노드는 자식을 여러 개 가질 수 있음
* 부모 parent
    * 어떤 노드에서 가지로 연결된 위쪽 노드
    * 노드는 1개의 부모를 가짐
* 형제 sibling
    * 같은 부모를 가지는 노드
* 조상 ancestor
    * 어떤 노드에서 가지로 연결된 위쪽 노드 모두
* 자손 descendant
    * 어떤 노드에서 가지로 연결된 아래쪽 노드 모두

**트리 관련 용어(3)**
* 레벨 level
    * 루트로부터 얼마나 떨어져 있는지에 대한 값
    * 루트의 레벨은 0이고 루트로부터 가지가 하나씩 아래로 뻗어나갈 때마다 레벨이 1씩 늘어남
* 차수 degree
    * 노드가 갖는 자식의 수
    * 모든 노드의 차수가 n 이하인 트리를 n진 트리라고 함
* 높이 height
    * 루트부터 가장 멀리 떨어진 리프까지의 거리 (리프 레벨의 최댓값)

**트리 관련 용어(4)**
* 서브 트리 subtree
    * 트리 안에서 다시 어떤 노드를 루트로 정하고 그 자손으로 이루어진 트리
* 널 트리 null tree
    * 노드, 가지가 없는 트리

**순서 트리와 무순서 트리 정의하기**
* 순서 트리와 무순서 트리
    * 형제 노드의 순서가 있는지 없는지에 따라 트리를 두 종류로 분류
    * 형제 노드의 순서를 따지면 순서 트리(ordered tree), 따지지 않으면 무순서 트리(unordered tree)라고 함

**너비 우선 탐색**
* 낮은 레벨에서 시작해 왼쪽에서 오른쪽 방향으로 검색하고 한 레벨에서의 검색이 끝나면 다음 레벨로 내려감
* 검색 순서: A -> B -> C -> D -> E -> F -> G -> H -> I -> J -> K -> L

**깊이 우선 탐색**
* 리프까지 내려가면서 검색하는 것을 우선순위로 하는 탐색 방법
* 리프에 도달해 더 이상 검색을 진행할 곳이 없는 경우에는 부모에게 돌아감
* 그런 다음 다시 자식 노드로 내려감
* 그림 9-5는 노드 A를 몇 번 지나갔는지를 나타낸 것
* 두 자식 가운데 한쪽(또는 양쪽)이 없으면 노드를 지나가는 횟수가 줄어들겠지만 노드를 지나가는 최댓값은 3회

**깊이 우선 탬색에서 가능한 노드 방문 종류**
* 전위 순회
    * (부모)노드 방문 -> 왼쪽 자식 -> 오른쪽 자식
    * A -> B -> D -> H -> E -> I -> J-> C -> F -> K -> L -> G
* 중위 순회
    * 왼쪽 자식 -> (부모)노드 방문 -> 오른쪽 자식
    * H -> D -> B -> I -> E -> J -> A -> K -> F -> L -> C -> G
* 후위 순회
    * 왼쪽 자식 -> 오른쪽 자식 -> (부모)노드 방문
    * H -> D -> I -> J -> E -> B -> K -> L -> F -> G -> C -> A

**이진 트리**
* 노드가 왼쪽 자식과 오른쪽 자식을 갖는 트리
* 노드의 자식은 2명 이하만 유지해야 함
* 왼쪽 자식과 오른쪽 자식을 구분함
* 왼쪽 자식을 다시 루트로 하는 서브 트리를 왼쪽 서브 트리, 오른쪽 자시을 다시 루트로 하는 서브 트리를 오른쪽 서브 트리라고 함

**완전 이진 트리**
* 루트부터 노드가 채워져 있으면서 같은 레벨에서는 왼쪽에서 오른쪽으로 노드가 채워져 있는 이진트리
    * 1. 마지막 레벨을 제외한 레벨은 노드를 가득 채움
    * 2. 마지막 레벨은 왼쪽부터 오른쪽 방향으로 노드를 채우되 반드시 끝까지 채울 필요는 없음
* 높이가 k인 완전이진트리가 가질 수 있는 노드의 최댓값은 2^(k+1)-1개
* 따라서 n개의 노드를 저장할 수 있는 완전이진트리의 높이는 log n
* 완전이진트리에서 너비 우선 탐색을 하며 각 노드에 0, 1, 2... 값을 주면 배열에 저장하는 인덱스와 일대일로 대응
* 보충 설명
    * 트리의 레벨은 루트에서부터 노드까지 거친 츠으이 수를 나타내며, 루트는 보통 0레벨 또는 1레벨로 본다.
    * 높이는 트리의 최대 레벨과 같으며, 루트에서 가장 먼 리프 노드까지의 경로에 있는 레벨 수(혹은 간선의 최대 개수)를 의미한다.
    * 높이가 h일 때 최대 노드의 수 n은 : n = 2^h - 1(단, 높이를 1서부터 시작)
    * n개의 노드를 가질 때, 완전 이진트리의 최대 높이 h는 : h = log2 n + 1 (단, 높이를 1서부터 시작)

**이진 검색 트리**
* 이진 트리가 다음의 조건을 만족
    * 1. 어떤 노드  N을 기준으로 왼쪽 서브 트리 노드의 모든 키값은 노드 N의 키값보다 작아야함
    * 2. 오른쪽 서브 트리 노드의 키값은 노드 N의 키값보다 커야 함
    * 3. 같은 키값을 갖는 노드는 없음
* 이진 검색 트리의 특징
    * 구조가 단순함
    * 중위 순회를 하면 키값이 오름차순으로 노드를 얻을 수 있음
    * 이진검색과 비슷한 방식으로 빠르게 검색할 수 있음
    * 노드를 삽입하기 쉬움
* 노드를 생성하는 AllocBinNode 함수
    * BinNode형 객체를 만드는 함수
* 노드 멤버값을 설정하는 SetBinNode 함수
    * BinNode형 객체의 3개 멤버에 값을 설정하는 함수로, 첫 번재 매개변수 n이 가리키는 BinNode형 객체에 대해 멤버값을 설정
    * n이 가리키는 객체 멤버인 data, left, right에 두 번째 매개변수 x가 가리키는 객체값 *x와 세 번째, 네 번째 매개변수의 포인터값 left, right를 각각 대입
* 비어 있는 상태의 이진 검색 트리 만들기
    * Initialize 함수 대신 그림 9-10과 같이 루트 노드를 가리키는 BinNode *형 객체를 하나 준비하고 널 값을 대입
    * 루트 노드를 가리키는 포인터는 이진검색트리를 사용하는 실습 9-3의 main 함수에서 미리 선언

**키 값으로 검색하는 Search 함수(1)**
    * a. 검색에 성공한 경우
        * 1. 루트를 선택(5): 3은 5보다 작기 때문에 왼쪽으로 검색을 진행
        * 2. 선택한 노드는 2: 3은 2보다 크기 때문에 오른쪽으로 검색을 진행
        * 3. 선택한 노드는 4: 3은 4보다 작기 때문에 왼쪽으로 검색을 진행
        * 4. 3에 도착해 검색에 성공
    * b. 검색에 실패하는 경우
        * 루트를 선택(5): 8은 5보다 크기 때문에 오른쪽으로 검색을 진행
        * 7을 선택: 7은 리프이고 오른쪽 자식 노드가 없으므로 더 이상 검색할 수 없기 때문에 검색에 실패

**키값으로 검색하는 Search 함수(2)**
* 첫 번째 매개변수 p를 루트로 하는 이진검색트리에서 검색을 수행
* 호출된 Search함수는 x가 가리키는 구조체 Memober형 객체와 같은 키값을 갖느 노드를 검색
* 검색에 성공하면 해당 노드에 대한 포인터를 반환

**노드를 삭제하는 Remove 함수(1)**
* 노드를 삭제할 때는 '세 가지 서로 다른 상황'에 놓이기 때문에 각각의 상황에 맞게 처리
* [A] 자식 노드가 없는 노드를 삭제하는 경우
    * 삭제할 노드가 부모 노드의 왼쪽 자식이면 부모의 왼쪽 포인터를 NULL로 함
    * 삭제할 노드가 부모 노드의 오른쪽 자식이면 부모의 오른쪽 포인터를 NULL로 함
* [B] 자식 노드가 1개인 노드를 삭제하는 경우
    * 삭제 대상 노드가 부모 노드의 왼쪽 자식인 경우 부모의 왼쪽 포인터가 삭제 대상 노드의 자식을 가리키도록 함
    * 삭제 대상 노드가 부모 노드의 오른쪽 자식인 경우 부모의 오른쪽 포인터가 삭제 대상 노드의 자식을 가리키도록 함
* [C] 자식 노드가 2개인 노드를 삭제하는 경우
    * 1. 삭제할 노드의 왼쪽 서브 트리에서 키값이 가장 큰 노드를 검색
    * 2. 검색한 노드를 삭제 위치로 옮김(검색한 노드의 데이터를 삭제 대상 노드 위치로 복사)
    * 3. 옮긴 노드를 삭제
        * 옮긴 노드에 자식이 없으면 [A] 자식 노드가 없는 노드를 삭제하는 경우'에 따라 노드를 삭제
        * 옮긴 노드에 자식이 1개만 있으면 '[B 자식 노드가 1개인 노드를 삭제하는 경우'에 따라 노드를 삭제

**노드를 삭제하는 Remove 함수 (2)**
* Search 함수와 Add 함수의 첫 번째 매개변수의 자료형은 BineNode *이지만 Remvoe 함수의 첫 번째 매개변수의 자료형은 BinNode **
* 이는 루트만 있는 이진 검색 트리에서 루트 노드를 삭제하는 경우에는 루트 포인터를 널로 업데이트하기 때문

**모든 노르를 출력하는 PrintTree 함수**
* 모든 노드를 키 값의 오름차순으로 출력하는 함수
* 오른차순으로 출력하기 위해 주우이 순회 방법으로 트리를 검색
* 처음 호출할 대 매개변수 p에 루트 노드의 포인터를 전달받음
* 회워느이 데이터 출력은 Member.c 에서 정의한 PrintLnMember 함수로 처리
* 이진 검색 트리의 모든 데이터를 키값의 오른차순으로 출력
    * 1. 노드 2를 가리키는 왼쪽 포인터를 PringTree 함수에 전달하면서 재귀호출
    * 2. 현재 노드의 데이터인 6을 출력
    * 3. 노드 7을 가리키는 오른쪽 포인터를 PrintTree 함수에 전달하면서 재귀호출

## 해시법
**정렬된 배열에 데이터를 추가**
* a 배열의 앞쪽 10개의 요소에 데이터가 오른차순으로 정렬된 상태로 저장
* 배열에 35을 추가하려면 아래와 같은 작업이 필요
    * 1. 삽입할 위치가 a[5]와 a[6]사이임을 이진검색법으로 조사
    * 2. 그림 b와 같이 a[6] 이후의 모든 요소를 하나씩 뒤로 이동
    * 3. a[6]에 35를 대입
* 요소 이동에 필요한 복잡도는 O(n)이며 이 비용은 적은 비용이 아님

**해시법(1)**
* 데이터를 저장할 위치(인덱스)를 간단한 연산으로 구하는 것으로, 검색뿐만 아니라 추가, 삭제도 효율적으로 수행하는 방법
* 그림 10-2의 a에서 볼 수 있는 배여르이 키값(각 요솟값)을 배열의 요소 개수 13으로 나눈 나머지로 다시 정리하면 표 10-1과 같음
* 표에 정리한 값을 해시값(hash value)이라고 하며, 이 해시값은 데이터에 접근하 ㄹ때 사용
* 해시값이 인덱스가 되도록 원래의 키값을 저장한 배열이 해시 테이블

**해시법(2)**
* 배열에 35를 추가하는 경우 35를 13으로 나눈 나머지는 9이므로 b처럼 a[9]에 값(35)을 저장
* 이전의 '추가한 값' 이후의 배열 요소를 모두 옮겼던 경우와는 다르게 새로운 값을 추가하더라도 다른 배열 요소를 뒤로 옮기지 않아도 됨
* 이러게 키값(35)을 가지고 해시값(9)을 만드는 과정을 해시 함수라고 함
* 해시 함수는 여기에서 살펴봤듯이 '나머지를 구하는 연산 또는 이런 나머지 연산을 다시 응용한 연산'을 사용
* 해시 테이브르이 각 요소를 버킷이라고 함

**충돌**
* 저장할 버킷이 중복되는 현상
* 배열에 새로운 값 18을 추가하는 경우 18을 13으로 나눈 나머지인 해시값은 5이고 저장하 ㄹ곳은 버킷a[5]
* 그런데 그림 10-3처럼 이 버킷은 이미 채워져 있음
* 키값과 해시값의 대응 관계가 반드시 1대1이라는 보증은 없음(보통 n대 1)

**충돌에 대한 대처**
* 1. 체인법: 같은 해시값을 갖는 요소를 연결 리스트로 관리
* 2. 오픈 주소법: 빈 버킷을 찾을 때까지 해시를 반복

**키값과 데이터**
* 해시법을 사용하는 프로그램에서 다루는 데이터는 단순한 정수나 실수가 아니라 여러 데이터가 결합된 '구조체'인 경우가 적지 않음
* 체인법과 오픈 주소법을 배우기 전에 프로그램에서 사용할 데이터인 구조체를 먼저 정의

**체인법**
* 해시값을 갖는 데이터를 쇠사슬 모양으로 연결 리스트에서 연결하는 방법으로, 오픈 해시법이라고도함

**같은 해시값을 갖는 네이터 저장하기**
* 배열의 각 버킷(해시 테이블)에 저장하는 값은 그 인덱스를 해시값으로 하는 연결 리스트의 첫 번째 노드에 대한 포인터
    * 그림 10-4에서 69와 17의 해시값은 모두 4이며, 이들을 연결하는 연결 리스트의 첫 번째 노드에 대한 포인터를 table[4]에 저장
    * 또 해시값(인덱스) 0과 2처럼 데이터가 하나도 없는 버킷의 값은 NULL 포인터값을 저장

**버킷용 구조체 Node8**
* 개별 버킷의 자료형을 나타낸 것
    * data... 데이터
    * next... 다음 노드에 대한 포인터로 다음 노드가 존재하지 않을 때는 NULL이 됨

**해시 테이블을 관리하는 구조체**
* size... 해시 테이블의 크기
* table... 해시 테이블을 저장하는 배열의 첫 번째 요소에 대한 포인터
* 멤버 table은 해시 테이블을 저장하는 배열(즉, 배열의 첫 번째 요소에 대한 포인터)
* 배열용 메모리 영역을 확보하는 작업은 Initialize 함수가 수행

**해시 테이블을 초기화하는 Initialize 함수**
* 첫 번째 인수 h는 처리 대상인 해시 구조체 객체에 대한 포인터
* 요소의 개수가 size인 배열 table의 본체를 생성하고 매개변수 size로 받은 값을 멤버 size에 복사
* 배열 table의 모든 요소에 공백 포인터 NULL을 대입했기 때문에 그림 10-6처럼 모든 버킷이 공백 상태
* 23~26행에서는 메모리 영역 확보에 실패(calloc 함수가 NULL을 반환)하면 멤버 table에 NULL을 대입하고, 멤버 size에 0을 대입

**키값으로 요소를 검색하는 Search 함수**
* 키값이 x -> no인 요소를 검색하는 함수
* 1. 해시 함수가 키값을 해시값으로 변환
* 2. 해시값을 인덱스로 하는 버킷을 선택
* 3. 선택한 버킷의 연결 리스트를 처음부터 순서대로 검색
    * 키값과 같은 값을 찾으면 검색 성공
    * 끝까지 스캔하여 찾지 못하면 검색 실패

**요소를 추가하는 Add 함수**
* 포인터 x가 가리키는 데이터를 추가하는 함수
* 1. 해시 함수가 키값을 해시값으로 변환
* 2. 해시값을 인덱스로 하는 버킷을 선택
* 3. 버킷에 저장된 포인터가 가리키는 연결 리스트를 처음부터 순서대로 검색
    * 키값과 같은 값을 찾으면 키값이 이미 등록된 상태이므로 추가에 실패
    * 끝까지 스캔하여 찾지 못하면 리스트의 맨 앞 위치에 노드를 삽입

**요소를 삭제하는 Remove 함수**
* 키값이 x -> no인 요소를 삭제하는 함수
* 1. 해시 함수가 키값을 해시값으로 변환
* 2. 해시값을 인덱스로 하는 버킷을 선택
* 3. 선택한 버킷의 포인터가 가리키는 연결 리스트를 처음부터 순서대로 검색
    * 키값과 같은 값을 찾으면 그 노드를 리스트에서 삭제
    * 그렇지 않으면 삭제에 실패

**모든 데이터를 삭제하는 Clear 함수**
* 1. 배열 표의 요소가 NULL이 아니면 그 해시값을 갖는 데이터가 연결 리스트로 존재하므로, 연결 리스트를 맨 앞부터 순서대로 검사하면서 모든 노드에 대한 메모리를 해제
* 2. 검사 중인 배열 요소에 NULL을 대입
* 3. 배열에 대한 모든 검사가 끝나면 모든 버킷이 '공백' 상태가 됨

**해시 테이블을 종료하는 Terminate 함수**
* 1. Clear 함수로 해시에 등록한 모든 데이터를 삭제
* 2. Initialize 함수로 메모리에 확보한 해시 테이블을 해제
* 3. 해시 테이블의 크기를 저장하는 멤버 size를 0으로 초기화

**오픈 주소법**
* 충돌이 발생했을 때 재해시를 수행하여 비어 있는 버킷을 찾아내는 방법으로, 닫힌 해시법이라고도 함
* 빈 버킷을 만날 때까지 재해시를 여러 번 반복하므로 연결 탐사법이라고도 함

**요소 삽입**
* a는 새로운 값(18)을 삽입하고자 할 때 충돌이 발생한 경우
* 이럴 때 사용하는 방법이 재해시
    * 재해시를 하면(18+1)%13의 결괏값(6)을 얻을 수 있음
* b 처럼 인덱스가 6인 버킷도 데이터가 채워져 있으므로 재해시
    * (19+1)%13의 결괏값(7)을 얻을 수 있음
* c처럼 인덱스가 7인 버킷에 새로운 데이터(18)를 삽입

**요소 삭제**
* 인덱스가 5인 값을 삭제하려면 인덱스가 5인 버킷의 데이터를 비우면 될 것 같지만 실제로는 그렇지 않음
* 왜냐하면 같은 해시값을 갖는 18을 검색할 때 '해시값이 5인 데이터는 존재하지 않는다'라고 생각하여 검색에 실패하기 때문
* 그래서 각 버킷에 대해 아래의 속성을 부여
    * 1. 데이터 저장 속성값
    * 2. 비어 있음 속성값(-)
    * 3. 삭제 마침 속성값(★)
* 5를 삭제할 때 그림 10-1 처럼 그 위치의 버킷에 삭제를 마쳤음을 나타내는 속성값으로 '★'을 저장

**요소검색**
* 값 17을 검색
    * 해시값이 4인 버킷을 보면 속성값이 '비어있음(-)' 이므로 검색 실패
* 값이 18을 검색
    * 해시값이 5인 버킷을 보면 그 속성은 '삭제 마침(★)'
    * 그림 10-11처럼 재해시를 수행하여 6인 버킷을 다시 검색
    * 여기에는 값 6이 저장되어 있으므로 다시 재해시를 수행하여 7인 버킷을 검색
    * 검색하는 값 18이 저장되어 있으므로 검색 성공